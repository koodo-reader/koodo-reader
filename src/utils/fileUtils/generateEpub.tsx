import { isTitle } from "./titleUtil";

const escapeHTML = (str) => {
  var escapeChars = {
    "¢": "cent",
    "£": "pound",
    "¥": "yen",
    "€": "euro",
    "©": "copy",
    "®": "reg",
    "<": "lt",
    ">": "gt",
    '"': "quot",
    "&": "amp",
    "'": "#39",
  };

  var regexString = "[";
  for (var key in escapeChars) {
    regexString += key;
  }
  regexString += "]";

  var regex = new RegExp(regexString, "g");
  return str.replace(regex, function (m) {
    return "&" + escapeChars[m] + ";";
  });
};
export const generateEpub = (file: any) => {
  return new Promise<File | number>((resolve, reject) => {
    const fs = window.require("fs");
    const path = window.require("path");
    const chardet = window.require("chardet");
    const { readFileSync } = window.require("fs");
    const iconv = window.require("iconv-lite");
    const nodepub = window.require("nodepub");
    const { remote, app } = window.require("electron");
    const configDir = (app || remote.app).getPath("userData");
    const dirPath = path.join(configDir, "uploads");
    const name = file.name;
    let bookExtension =
      name.indexOf("mobi") > -1
        ? "mobi"
        : name.indexOf("azw3") > -1
        ? "azw3"
        : name.split(".").reverse()[0];
    let bookName = name.substr(
      0,
      name.length - (bookExtension !== "txt" ? 8 : 3) - 1
    );
    var reader = new FileReader();
    reader.readAsArrayBuffer(file);
    reader.onload = (event) => {
      fs.writeFileSync(
        path.join(dirPath, file.name),
        Buffer.from(event.target!.result as any)
      );
      var metadata = {
        id: new Date().getTime(),
        title: bookName,
        author: "Unknown Authur",
        fileAs: "Anonymous",
        genre: "Non-Fiction",
        tags: "Sample,Example,Test",
        copyright: "Anonymous, 2020",
        publisher: bookExtension,
        published: new Date().toLocaleDateString(),
        language: "cn",
        description: "A book generated by Koodo Reader",
        contents: "Content",
        source: "https://koodo.960960.xyz",
        images: [path.join(dirPath, `cover.png`)],
      };

      // Set up the EPUB basics.
      var epub = nodepub.document(metadata, path.join(dirPath, `cover.png`));
      let content: any = [];
      const analyzeChapter = () => {
        const data = readFileSync(path.join(dirPath, file.name), {
          encoding: "binary",
        });
        const buf = new Buffer(data, "binary");
        const lines = iconv.decode(buf, chardet.detect(buf)).split("\n");
        const lineLength = lines.length;
        const imgIndex = lines.indexOf("~image");
        const images = lines.slice(imgIndex).filter((item) => {
          return item.startsWith("data");
        });
        lines.splice(imgIndex, lineLength - imgIndex);
        let isContainDI = false;
        let isContainChapter = false;
        let isContainCHAPTER = false;
        for (let item of lines) {
          const line = escapeHTML(item).trim();
          if (isTitle(line, isContainDI, isContainChapter, isContainCHAPTER)) {
            if (line.startsWith("第")) {
              isContainDI = true;
            }
            if (line.startsWith("Chapter")) {
              isContainChapter = true;
            }
            if (line.startsWith("CHAPTER")) {
              isContainCHAPTER = true;
            }
            content.push({
              title: line,
              data: "",
            });
          } else if (line) {
            if (!content[content.length - 1]) {
              content.push({
                title: "Forward",
                data: "",
              });
            }
            if (line === "#image") {
              if (images.length > 0) {
                content[content.length - 1].data += `<img src="${
                  images[0].split(" ")[0]
                }" style="margin-left: calc(50% - ${
                  // eslint-disable-next-line
                  parseInt(images[0].split(" ")[1]) / 2 + "" + "px"
                })"  width="${images[0].split(" ")[1]}px"  height="${
                  images[0].split(" ")[2]
                }px"/>`;
                images.shift();
              } else {
                content[content.length - 1].data += `<img src=" "/>`;
              }
            } else if (!line.startsWith("*")) {
              content[
                content.length - 1
              ].data += `<p style="text-indent:2em">${line}</p>`;
            }
          }
        }
      };
      analyzeChapter();
      if (content.length < 3) {
        resolve(2);
      }
      for (let item of content) {
        epub.addSection(item.title, `<h1>${item.title}</h1>` + item.data);
      }

      epub.writeEPUB(
        function (e) {
          console.log("Error:", e);
          resolve(1);
        },
        dirPath,
        bookName,
        function () {
          var data = fs.readFileSync(path.join(dirPath, `${bookName}.epub`));
          let blobTemp = new Blob([data], { type: "application/epub+zip" });
          let fileTemp = new File([blobTemp], `${bookName}.epub`, {
            lastModified: new Date().getTime(),
            type: blobTemp.type,
          });

          try {
            const fs = window.require("fs-extra");
            fs.remove(path.join(dirPath, `${bookName}.epub`), (err) => {
              if (err) throw err;
              console.log("successfully epub deleted");
            });
            fs.remove(path.join(dirPath, file.name), (err) => {
              if (err) throw err;
              console.log("successfully file deleted");
            });

            resolve(fileTemp);
          } catch (e) {
            console.log("error removing ");
            resolve(1);
          }
        }
      );
    };
  });
};
